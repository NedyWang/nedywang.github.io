---
layout: post
title:  "memcached libevent"
date:   2018-01-20 16:49:10 -0800
categories: libevent
---

# libevent在memcached中的实际使用

## 总体框架

![](../pics/memcached_libevent.png)


## 初始化创建worker线程

调用函数memcached_thread_init实现

```
/**
 * 申请n个libevent线程，初始化，并且创建n个子线程
 * @nthreads worker线程的数量
 * @arg
 */
void memcached_thread_init(int nthreads, void *arg)
```

```dot
digraph memcachedThdInit{
    node [shape=box, penwidth=2]
    edge [penwidth=2, style=dashed]

    A [label="start", shape=ellipse]
    B [label="allocate related locks"]

    C [label="i < nthreads"]
    D [label="init pipe, assign it to sendfd and recv fd"]
    E [label="call setup_thread"]

    F [label="loop to call create_worker"]
    W [label="wait_for_thread_registration"]
    End [shape=ellipse]

    A->B->C
    C->D [label="yes"]
    D->E->C
    C->F [label="no"]


    F->W->End
}
```


## LIBEVENT_THREAD

libevent线程结构体
需要理解的是notify_event和notify_received_fd/notify_send_fd
框架图的worker线程模块，notify_event事件是和notify_received_fd绑定的，notify_received_fd是pipe的读端，notify_send_fd是pipe的写端，可读时说明主线程是有新连接到达，然后通知workder线程去new_conn_queue中取连接。

```
typedef struct {
    pthread_t thread_id;        /* unique ID of this thread */
    struct event_base *base;    /* libevent handle this thread uses */
    struct event notify_event;  /* listen event for notify pipe */
    int notify_receive_fd;      /* receiving end of notify pipe */
    int notify_send_fd;         /* sending end of notify pipe */
    struct thread_stats stats;  /* Stats generated by this thread */
    struct conn_queue *new_conn_queue; /* queue of new connections to handle */
    cache_t *suffix_cache;      /* suffix cache */
#ifdef EXTSTORE
    cache_t *io_cache;          /* IO objects */
    void *storage;              /* data object for storage system */
#endif
    logger *l;                  /* logger buffer */
    void *lru_bump_buf;         /* async LRU bump buffer */
} LIBEVENT_THREAD;
```


## setup_thread


```
/**
 * 设置me的信息
 * @me LIBEVENT_THREAD
 */
static void setup_thread(LIBEVENT_THREAD *me)
```

```dot
digraph setup_thread {
    node [shape=box, penwidth=2]
    edge [penwidth=2, style=dashed]

    A [label="分配event_base"]
    B [label="将notify_receive_fd和notify_event绑定"]
    C [label="将notify_event注册到event_base中去"]
    D [label="初始化new_conn_queue"]
    E [label="初始化suffix_cache"]

    A->B->C->D->E
}
```


## worker_libevent

进入event_base主事件循环

```
/*
 * Worker thread: main event loop
 */
static void *worker_libevent(void *arg) {
    LIBEVENT_THREAD *me = arg;

    /* Any per-thread setup can happen here; memcached_thread_init() will block until
     * all threads have finished initializing.
     */
    me->l = logger_create();
    me->lru_bump_buf = item_lru_bump_buf_create();
    if (me->l == NULL || me->lru_bump_buf == NULL) {
        abort();
    }

    if (settings.drop_privileges) {
        drop_worker_privileges();
    }

    register_thread_initialized();

    event_base_loop(me->base, 0);
    return NULL;
```

## create_worker

memcached_thread_init中对create_worker的调用形式：
```
create_worker(worker_libevent, &threads[i])
```
工作函数是worer_libevent

create_worker只是将pthread_create包装了下
```
/**
 * Creates a worker thread.
 */
static void create_worker(void *(*func)(void *), void *arg) {
    pthread_attr_t  attr;
    int             ret;

    pthread_attr_init(&attr);

    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
        fprintf(stderr, "Can't create thread: %s\n",
                strerror(ret));
        exit(1);
    }
}
```


## new_conn_queue

一个简单的单链表

```
typedef struct conn_queue_item CQ_ITEM;

struct conn_queue_item {
    int               sfd;
    enum conn_states  init_state;
    int               event_flags;
    int               read_buffer_size;
    enum network_transport     transport;
    enum conn_queue_item_modes mode;
    conn *c;
    CQ_ITEM          *next;
};

typedef struct conn_queue CQ;
struct conn_queue {
    CQ_ITEM *head;
    CQ_ITEM *tail;
    pthread_mutex_t lock;
};
```

conn_conn是单链表，head指向链表头，tail指向链表尾部，因为链表涉及到多线程访问，因此设置了个lock。

conn_queue_item是对主线程accept的connection的包装。
